"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/rules/exhaustive-deps.rule.ts
var exhaustive_deps_rule_exports = {};
__export(exhaustive_deps_rule_exports, {
  name: () => name,
  rule: () => rule
});
module.exports = __toCommonJS(exhaustive_deps_rule_exports);
var import_utils = require("@typescript-eslint/utils");
var import_ast_utils = require("../utils/ast-utils.cjs");
var import_create_rule = require("../utils/create-rule.cjs");
var import_unique_by = require("../utils/unique-by.cjs");
var import_exhaustive_deps = require("./exhaustive-deps.utils.cjs");
var QUERY_KEY = "queryKey";
var QUERY_FN = "queryFn";
var name = "exhaustive-deps";
var rule = (0, import_create_rule.createRule)({
  name,
  meta: {
    type: "problem",
    docs: {
      description: "Exhaustive deps rule for useQuery",
      recommended: "error"
    },
    messages: {
      missingDeps: `The following dependencies are missing in your queryKey: {{deps}}`,
      fixTo: "Fix to {{result}}"
    },
    hasSuggestions: true,
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      Property(node) {
        if (node.parent === void 0 || !import_ast_utils.ASTUtils.isObjectExpression(node.parent) || !import_ast_utils.ASTUtils.isIdentifierWithName(node.key, QUERY_KEY)) {
          return;
        }
        const scopeManager = context.getSourceCode().scopeManager;
        const queryKey = import_ast_utils.ASTUtils.findPropertyWithIdentifierKey(
          node.parent.properties,
          QUERY_KEY
        );
        const queryFn = import_ast_utils.ASTUtils.findPropertyWithIdentifierKey(
          node.parent.properties,
          QUERY_FN
        );
        if (scopeManager === null || queryKey === void 0 || queryFn === void 0 || queryFn.value.type !== import_utils.AST_NODE_TYPES.ArrowFunctionExpression) {
          return;
        }
        let queryKeyNode = queryKey.value;
        if (queryKeyNode.type === import_utils.AST_NODE_TYPES.TSAsExpression && queryKeyNode.expression.type === import_utils.AST_NODE_TYPES.ArrayExpression) {
          queryKeyNode = queryKeyNode.expression;
        }
        if (queryKeyNode.type === import_utils.AST_NODE_TYPES.Identifier) {
          const expression = import_ast_utils.ASTUtils.getReferencedExpressionByIdentifier({
            context,
            node: queryKeyNode
          });
          if ((expression == null ? void 0 : expression.type) === import_utils.AST_NODE_TYPES.ArrayExpression) {
            queryKeyNode = expression;
          }
        }
        const sourceCode = context.getSourceCode();
        const queryKeyValue = queryKeyNode;
        const externalRefs = import_ast_utils.ASTUtils.getExternalRefs({
          scopeManager,
          sourceCode,
          node: queryFn.value
        });
        const relevantRefs = externalRefs.filter(
          (reference) => import_exhaustive_deps.ExhaustiveDepsUtils.isRelevantReference({
            context,
            reference,
            scopeManager
          })
        );
        const existingKeys = import_ast_utils.ASTUtils.getNestedIdentifiers(queryKeyValue).map(
          (identifier) => import_ast_utils.ASTUtils.mapKeyNodeToText(identifier, sourceCode)
        );
        const missingRefs = relevantRefs.map((ref) => ({
          ref,
          text: import_ast_utils.ASTUtils.mapKeyNodeToText(ref.identifier, sourceCode)
        })).filter(({ ref, text }) => {
          return !ref.isTypeReference && !import_ast_utils.ASTUtils.isAncestorIsCallee(ref.identifier) && !existingKeys.some((existingKey) => existingKey === text) && !existingKeys.includes(text.split(".")[0] ?? "");
        }).map(({ ref, text }) => ({
          identifier: ref.identifier,
          text
        }));
        const uniqueMissingRefs = (0, import_unique_by.uniqueBy)(missingRefs, (x) => x.text);
        if (uniqueMissingRefs.length > 0) {
          const missingAsText = uniqueMissingRefs.map((ref) => import_ast_utils.ASTUtils.mapKeyNodeToText(ref.identifier, sourceCode)).join(", ");
          const existingWithMissing = sourceCode.getText(queryKeyValue).replace(/\]$/, `, ${missingAsText}]`);
          const suggestions = [];
          if (queryKeyNode.type === import_utils.AST_NODE_TYPES.ArrayExpression) {
            suggestions.push({
              messageId: "fixTo",
              data: { result: existingWithMissing },
              fix(fixer) {
                return fixer.replaceText(queryKeyValue, existingWithMissing);
              }
            });
          }
          context.report({
            node,
            messageId: "missingDeps",
            data: {
              deps: uniqueMissingRefs.map((ref) => ref.text).join(", ")
            },
            suggest: suggestions
          });
        }
      }
    };
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  name,
  rule
});
//# sourceMappingURL=exhaustive-deps.rule.cjs.map