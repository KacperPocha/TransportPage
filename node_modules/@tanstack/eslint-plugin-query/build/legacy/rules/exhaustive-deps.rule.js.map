{"version":3,"sources":["../../../src/rules/exhaustive-deps.rule.ts"],"sourcesContent":["import { AST_NODE_TYPES } from '@typescript-eslint/utils'\nimport { ASTUtils } from '../utils/ast-utils'\nimport { createRule } from '../utils/create-rule'\nimport { uniqueBy } from '../utils/unique-by'\nimport { ExhaustiveDepsUtils } from './exhaustive-deps.utils'\nimport type { TSESLint } from '@typescript-eslint/utils'\n\nconst QUERY_KEY = 'queryKey'\nconst QUERY_FN = 'queryFn'\n\nexport const name = 'exhaustive-deps'\n\nexport const rule = createRule({\n  name,\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Exhaustive deps rule for useQuery',\n      recommended: 'error',\n    },\n    messages: {\n      missingDeps: `The following dependencies are missing in your queryKey: {{deps}}`,\n      fixTo: 'Fix to {{result}}',\n    },\n    hasSuggestions: true,\n    fixable: 'code',\n    schema: [],\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      Property(node) {\n        if (\n          node.parent === undefined ||\n          !ASTUtils.isObjectExpression(node.parent) ||\n          !ASTUtils.isIdentifierWithName(node.key, QUERY_KEY)\n        ) {\n          return\n        }\n\n        const scopeManager = context.getSourceCode().scopeManager\n        const queryKey = ASTUtils.findPropertyWithIdentifierKey(\n          node.parent.properties,\n          QUERY_KEY,\n        )\n        const queryFn = ASTUtils.findPropertyWithIdentifierKey(\n          node.parent.properties,\n          QUERY_FN,\n        )\n\n        if (\n          scopeManager === null ||\n          queryKey === undefined ||\n          queryFn === undefined ||\n          queryFn.value.type !== AST_NODE_TYPES.ArrowFunctionExpression\n        ) {\n          return\n        }\n\n        let queryKeyNode = queryKey.value\n\n        if (\n          queryKeyNode.type === AST_NODE_TYPES.TSAsExpression &&\n          queryKeyNode.expression.type === AST_NODE_TYPES.ArrayExpression\n        ) {\n          queryKeyNode = queryKeyNode.expression\n        }\n\n        if (queryKeyNode.type === AST_NODE_TYPES.Identifier) {\n          const expression = ASTUtils.getReferencedExpressionByIdentifier({\n            context,\n            node: queryKeyNode,\n          })\n\n          if (expression?.type === AST_NODE_TYPES.ArrayExpression) {\n            queryKeyNode = expression\n          }\n        }\n\n        const sourceCode = context.getSourceCode()\n        const queryKeyValue = queryKeyNode\n        const externalRefs = ASTUtils.getExternalRefs({\n          scopeManager,\n          sourceCode,\n          node: queryFn.value,\n        })\n\n        const relevantRefs = externalRefs.filter((reference) =>\n          ExhaustiveDepsUtils.isRelevantReference({\n            context,\n            reference,\n            scopeManager,\n          }),\n        )\n\n        const existingKeys = ASTUtils.getNestedIdentifiers(queryKeyValue).map(\n          (identifier) => ASTUtils.mapKeyNodeToText(identifier, sourceCode),\n        )\n\n        const missingRefs = relevantRefs\n          .map((ref) => ({\n            ref: ref,\n            text: ASTUtils.mapKeyNodeToText(ref.identifier, sourceCode),\n          }))\n          .filter(({ ref, text }) => {\n            return (\n              !ref.isTypeReference &&\n              !ASTUtils.isAncestorIsCallee(ref.identifier) &&\n              !existingKeys.some((existingKey) => existingKey === text) &&\n              !existingKeys.includes(text.split('.')[0] ?? '')\n            )\n          })\n          .map(({ ref, text }) => ({\n            identifier: ref.identifier,\n            text: text,\n          }))\n\n        const uniqueMissingRefs = uniqueBy(missingRefs, (x) => x.text)\n\n        if (uniqueMissingRefs.length > 0) {\n          const missingAsText = uniqueMissingRefs\n            .map((ref) => ASTUtils.mapKeyNodeToText(ref.identifier, sourceCode))\n            .join(', ')\n\n          const existingWithMissing = sourceCode\n            .getText(queryKeyValue)\n            .replace(/\\]$/, `, ${missingAsText}]`)\n\n          const suggestions: TSESLint.ReportSuggestionArray<string> = []\n\n          if (queryKeyNode.type === AST_NODE_TYPES.ArrayExpression) {\n            suggestions.push({\n              messageId: 'fixTo',\n              data: { result: existingWithMissing },\n              fix(fixer) {\n                return fixer.replaceText(queryKeyValue, existingWithMissing)\n              },\n            })\n          }\n\n          context.report({\n            node: node,\n            messageId: 'missingDeps',\n            data: {\n              deps: uniqueMissingRefs.map((ref) => ref.text).join(', '),\n            },\n            suggest: suggestions,\n          })\n        }\n      },\n    }\n  },\n})\n"],"mappings":"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","names":[]}