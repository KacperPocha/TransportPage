"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/ast-utils.ts
var ast_utils_exports = {};
__export(ast_utils_exports, {
  ASTUtils: () => ASTUtils
});
module.exports = __toCommonJS(ast_utils_exports);
var import_utils = require("@typescript-eslint/utils");
var import_unique_by = require("./unique-by.cjs");
var ASTUtils = {
  isNodeOfOneOf(node, types) {
    return types.includes(node.type);
  },
  isIdentifier(node) {
    return node.type === import_utils.AST_NODE_TYPES.Identifier;
  },
  isIdentifierWithName(node, name) {
    return ASTUtils.isIdentifier(node) && node.name === name;
  },
  isIdentifierWithOneOfNames(node, name) {
    return ASTUtils.isIdentifier(node) && name.includes(node.name);
  },
  isProperty(node) {
    return node.type === import_utils.AST_NODE_TYPES.Property;
  },
  isObjectExpression(node) {
    return node.type === import_utils.AST_NODE_TYPES.ObjectExpression;
  },
  isPropertyWithIdentifierKey(node, key) {
    return ASTUtils.isProperty(node) && ASTUtils.isIdentifierWithName(node.key, key);
  },
  findPropertyWithIdentifierKey(properties, key) {
    return properties.find(
      (x) => ASTUtils.isPropertyWithIdentifierKey(x, key)
    );
  },
  getNestedIdentifiers(node) {
    const identifiers = [];
    if (ASTUtils.isIdentifier(node)) {
      identifiers.push(node);
    }
    if ("arguments" in node) {
      node.arguments.forEach((x) => {
        identifiers.push(...ASTUtils.getNestedIdentifiers(x));
      });
    }
    if ("elements" in node) {
      node.elements.forEach((x) => {
        if (x !== null) {
          identifiers.push(...ASTUtils.getNestedIdentifiers(x));
        }
      });
    }
    if ("properties" in node) {
      node.properties.forEach((x) => {
        identifiers.push(...ASTUtils.getNestedIdentifiers(x));
      });
    }
    if ("expressions" in node) {
      node.expressions.forEach((x) => {
        identifiers.push(...ASTUtils.getNestedIdentifiers(x));
      });
    }
    if (node.type === import_utils.AST_NODE_TYPES.Property) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.value));
    }
    if (node.type === import_utils.AST_NODE_TYPES.SpreadElement) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument));
    }
    if (node.type === import_utils.AST_NODE_TYPES.MemberExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.object));
    }
    if (node.type === import_utils.AST_NODE_TYPES.UnaryExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument));
    }
    if (node.type === import_utils.AST_NODE_TYPES.ChainExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.expression));
    }
    if (node.type === import_utils.AST_NODE_TYPES.TSNonNullExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.expression));
    }
    return identifiers;
  },
  isAncestorIsCallee(identifier) {
    let previousNode = identifier;
    let currentNode = identifier.parent;
    while (currentNode !== void 0) {
      if (currentNode.type === import_utils.AST_NODE_TYPES.CallExpression && currentNode.callee === previousNode) {
        return true;
      }
      if (currentNode.type !== import_utils.AST_NODE_TYPES.MemberExpression) {
        return false;
      }
      previousNode = currentNode;
      currentNode = currentNode.parent;
    }
    return false;
  },
  traverseUpOnly(identifier, allowedNodeTypes) {
    const parent = identifier.parent;
    if (parent !== void 0 && allowedNodeTypes.includes(parent.type)) {
      return ASTUtils.traverseUpOnly(parent, allowedNodeTypes);
    }
    return identifier;
  },
  isDeclaredInNode(params) {
    const { functionNode, reference, scopeManager } = params;
    const scope = scopeManager.acquire(functionNode);
    if (scope === null) {
      return false;
    }
    return scope.set.has(reference.identifier.name);
  },
  getExternalRefs(params) {
    const { scopeManager, sourceCode, node } = params;
    const scope = scopeManager.acquire(node);
    if (scope === null) {
      return [];
    }
    const references = scope.references.filter((x) => x.isRead() && !scope.set.has(x.identifier.name)).map((x) => {
      const referenceNode = ASTUtils.traverseUpOnly(x.identifier, [
        import_utils.AST_NODE_TYPES.MemberExpression,
        import_utils.AST_NODE_TYPES.Identifier
      ]);
      return {
        variable: x,
        node: referenceNode,
        text: sourceCode.getText(referenceNode)
      };
    });
    const localRefIds = new Set(
      [...scope.set.values()].map((x) => sourceCode.getText(x.identifiers[0]))
    );
    const externalRefs = references.filter(
      (x) => x.variable.resolved === null || !localRefIds.has(x.text)
    );
    return (0, import_unique_by.uniqueBy)(externalRefs, (x) => x.text).map((x) => x.variable);
  },
  mapKeyNodeToText(node, sourceCode) {
    return sourceCode.getText(
      ASTUtils.traverseUpOnly(node, [
        import_utils.AST_NODE_TYPES.MemberExpression,
        import_utils.AST_NODE_TYPES.Identifier
      ])
    );
  },
  isValidReactComponentOrHookName(identifier) {
    return identifier !== null && identifier !== void 0 && /^(use|[A-Z])/.test(identifier.name);
  },
  getFunctionAncestor(context) {
    var _a;
    for (const ancestor of context.getAncestors()) {
      if (ancestor.type === import_utils.AST_NODE_TYPES.FunctionDeclaration) {
        return ancestor;
      }
      if (((_a = ancestor.parent) == null ? void 0 : _a.type) === import_utils.AST_NODE_TYPES.VariableDeclarator && ancestor.parent.id.type === import_utils.AST_NODE_TYPES.Identifier && ASTUtils.isNodeOfOneOf(ancestor, [
        import_utils.AST_NODE_TYPES.FunctionDeclaration,
        import_utils.AST_NODE_TYPES.FunctionExpression,
        import_utils.AST_NODE_TYPES.ArrowFunctionExpression
      ])) {
        return ancestor;
      }
    }
    return void 0;
  },
  getReferencedExpressionByIdentifier(params) {
    var _a, _b, _c;
    const { node, context } = params;
    const resolvedNode = (_c = (_b = (_a = context.getScope().references.find((ref) => ref.identifier === node)) == null ? void 0 : _a.resolved) == null ? void 0 : _b.defs[0]) == null ? void 0 : _c.node;
    if ((resolvedNode == null ? void 0 : resolvedNode.type) !== import_utils.AST_NODE_TYPES.VariableDeclarator) {
      return null;
    }
    return resolvedNode.init;
  },
  getClosestVariableDeclarator(node) {
    let currentNode = node;
    while (currentNode !== void 0 && currentNode.type !== import_utils.AST_NODE_TYPES.Program) {
      if (currentNode.type === import_utils.AST_NODE_TYPES.VariableDeclarator) {
        return currentNode;
      }
      currentNode = currentNode.parent;
    }
    return void 0;
  },
  getNestedReturnStatements(node) {
    const returnStatements = [];
    if (node.type === import_utils.AST_NODE_TYPES.ReturnStatement) {
      returnStatements.push(node);
    }
    if ("body" in node && node.body !== void 0 && node.body !== null) {
      Array.isArray(node.body) ? node.body.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      }) : returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.body)
      );
    }
    if ("consequent" in node) {
      Array.isArray(node.consequent) ? node.consequent.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      }) : returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.consequent)
      );
    }
    if ("alternate" in node && node.alternate !== null) {
      Array.isArray(node.alternate) ? node.alternate.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      }) : returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.alternate)
      );
    }
    if ("cases" in node) {
      node.cases.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      });
    }
    if ("block" in node) {
      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.block));
    }
    if ("handler" in node && node.handler !== null) {
      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.handler));
    }
    if ("finalizer" in node && node.finalizer !== null) {
      returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.finalizer)
      );
    }
    if ("expression" in node && node.expression !== true && node.expression !== false) {
      returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.expression)
      );
    }
    if ("test" in node && node.test !== null) {
      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.test));
    }
    return returnStatements;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ASTUtils
});
//# sourceMappingURL=ast-utils.cjs.map